# leetcode刷题
# 分类说明
* 其实我也没有什么好的分类方法，而且leecode上面是一个class一道题目，所以我干脆就一个文件放20道题目
## 001号文件
### 01号题目
* leetcode.122.买卖股票的最佳时机Ⅱ
* 思路：只要是上涨区间我就有利可循。所以可以采用贪心算法，先把所有区间分为一个个间隔为1的小区间，然后使用贪心算法对其进行求解

### 02号题目
* leetcode.55.跳跃游戏
* 思路：有一点点动态规划的意思，由于不确定中间最大跨越步数是多少，所以遍历一遍整个数组是必要的。设置一个最大跨越书rightmax初始化为0，然后每次变量一个数就进行更新，取max(rightmax,nunms[i]+i)。如果i比rightmax大，说明中间某一时刻已经无法覆盖当前的i了，直接返回false。如果最后rightmax>=size-1那么说明可以跳到最后一个格子。

### 03号题目
* leetcode.45.跳跃游戏2
* 思路：这个题目和第一个题目还是有些不一样。这次我们得去观察次数最少的情况。不过我们其实并不关心每一次跳到了哪一个格子，而是关心每一步的覆盖范围，覆盖范围之内就是一步的事情。所以在用rightmax给end赋值的时候，就可以大胆赋值了，因为一个范围内都是一步，随便调整路线最后用的步数都是一样的。每一次调整都要让步数自增，最后返回步数就好

### 04号题目
* leetcode.274. H指数
* 读懂题目就好说，所以我用一个数组记录每一个论文的引用数，然后倒序搜索，用累加和和最后的i进行比较

### 05号题目
* leetcode.380.O(1)时间插入、删除和获取随机元素
* 思路：其实是一个语法题，就当复习一下unordered_map和vector的使用了。不过交换到尾部再进行删除确确实实是一个不错的技巧

### 06号题目
* leetcode.238.除自身外数组乘积
* 思路：设计一个前缀数组和后缀数组，分别保存前缀乘积（不含自身）和后缀乘积，最后构造ans的时候两个数组对应相乘就好

### 07号题目
*  leetcode.134.加油站
*  思路：这个题目的关键在于油箱里面的油量在前往终点的途中不能小于0.这里可以在脑袋里想象一个折线图，横坐标是每一个点，纵坐标是加油量和耗油量的差值，然后我们希望做到的就是让这个折线图全部在x轴上方。然后再想一想，如果改变起点，折线的走势不会变，但是最终效果变成了折线整体的上下平移。但是折线上各个点的相对位置不会变。所以，为了让折线尽可能地向上平移，我们需要找到最低点，让它为起点。如果这样都无法满足条件，那么必然我们也无法回到起点。
  
### 08号题目
* leetcode.13罗马数字转整数
* 思路：一个模拟题，麻烦但是不难，使用一个unordered_mp就可以很好的解决

### 09号题目
* leetcode.12 整数转罗马数字
* 思路：其实还是一个模拟题，但是和前面相比要难一些。可以进行一个类比，我们是十进制有十个数字来表示，罗马数字也是特有的罗马进制，只不过他们的构成单位比较复杂而已。再想一想我们是怎么把十进制转换为其他进制的，这个时候就需要我们从高位开始减，直到减到不能减最终减到0位为止。这一题其实大概也是这个思路。就是一个数制转换

### 10号题目
* leetcode.56.最后一个单词的长度
* 思路：就是找出最后一个单词，不过需要注意一些细节。首先就是可能末尾有很多空格，也有可能是个字符只有一个的串。细节做好这个题就不难。

### 11号题目
* leetcode.14.最长公共前缀
* 思路：模拟题，首先排除存在空串、只有一个串的情况，然后遍历第一个串并且看其他串对应字符和第一个串是否相等，相等的话就把这个字符加入答案，否则就退出循环。

### 12号题目
* leetcode.151.反转字符串中的单词
* 思路:我希望遍历一遍字符串就把问题解决，所以我需要用continue来处理空格的细节，然后每个单词作为一个独立的字符串插入vector尾部，最后再拼接，并且插入合适的空格，就行了。
* 本题出错在于continue之前我没有改变i的值，导致超出内存范围

### 13号题目
* leetcode.28.找出字符串中第一个匹配的下标
* 思路：简单的话就用find，难一点的话用kmp，这个明天再看吧，因为有点困了懒得学东西
* string::npos可以理解为-1,用来判断是否有子串，而且find的返回值还得做一下类型强制转换

### 14号题目
* leetcode.392.判断子序列
* 思路：这是一道很不错的双指针题目，但是需要注意。遍历子串作为外循环，遍历母串是内循环，遍历母串的时候不能走回头路。如果母串走完了子串还没走完，那么就肯定不是了，否则就是。
* 没过的原因：每次匹配成功后没有吧j自增，导致j原地踏步，所以当有连续字符相同的子串出现的时候就会卡出而造成答案错误

### 15号题目
* leetcode.167.两数之和二--输入有序数组
* 思路：本题解法基础是双指针，但是却不是浅显的双指针。这一题由于解是一个二维坐标，实际上我们的搜索空间就是一个二维的，哪怕规定i和j的大小关系，也只能小一半的搜索空间。所以我们可以琢磨一下怎么去减少搜索空间。当a[i]+a[j]<目标如果i不动，那么比j小的都没有意义了。反之依然。一个1不动另一个移动，而不是两者同时动，这样可以做到搜索不漏。而不是简简单单的吧i和j分别只能自增自减随意套到解法中去，本质上还是要思考如何在合理的情况下逐步缩小搜索空间。

### 16号题目
* leetcode.11.盛最多水的容器.
* 思路：本题双指针还是要思考如何缩小搜索空间，指针每一次移动，都意味着排除掉了一个柱子。其实双指针的一般操作也可以给我们一些启发，一开始两个指针就放在两端。
* 在这个基础之上我们就可以分析每一次移动柱子对这个题目的影响是什么：首先每一次移动有一个是确定的，那就是减少了宽度。而且水面高度是由短柱子决定的，所以移动高柱子的话一定不会让结果更优，所以我们就只能去移动那根低柱子。直到双指针相遇，这个算法就停止了
* 之前思考出现过一些误区：我老是想着得到更好的收益，也就是说我希望我的移动让短柱子变成长柱子，这样才可能优化解。这种想法我觉得没错，但是我并不知道下一根柱子在哪里，如果在这纠结可能导致指针卡住。所以不妨放松一点条件，只要是短的柱子我们就可以移动。毕竟双指针某种意义上也是一种搜索算法，也就是会试探未知。

### 17号题目
* leetcode.7.Z字形变换
* 思路：咱们还是按行处理，遍历字符串的时候可以发现，行号先由0然后到n-1,再由n-1到0。所以我们利用这一点把字符串分到不同的行中，最后拼接起来即可
* 这个题我学到了一个flag的用法，初值的设置引起了我的思考。解题的时候一定是有限的，但是我们可以在无限的条件下思考初值该设置什么

### 18号题目
* leetcode.15.三数之和
* 思路：暴力三重循环也能做，但是不够优美
* 本题体现了我的双指针还是不够熟练。首先进行简单的数学分析，三数之和为0，那么说明最小值小于等于0，最大值大于等于0。为了方便，我们先对数组进行排序。这里我们不妨还是规定一下三个数的顺序，这遍历起来可以少干一些工作。首先确定最小值的位置，然后在数组后面部分进行双指针遍历。每一次得到解，或者每一次移动都需要让指针跳跃，直到不同的数值，以此来规避重复解。其它的也没什么好说的
* 双指针可以是整个题目双指针，也可以是某一步双指针，目前来说，双指针的本质就是减少搜索量，而这个减少的依据也就变成了移动指针的条件。所以要灵活应用

### 19号题目
* leetcode.209.长度最小的子数组
* 思路:这里采用的是滑动窗口的办法。首先我让快指针递增，直到sum比target大，然后再自增慢指针，减到sum恰好比taget小。直到遍历所有的元素

### 20号题目
* leetcode.3.无重复字符的最长子串
* 思路：这个题仍然用的是滑动窗口，但是我开始的时候没有想出来。首先如何确定字符串内没有重复元素？这里借助了一个unordered_map。运用查找函数就可以判断，当然我们的map没有移除元素的设计，那么如何判断某些元素已经不在了呢？这里我们想研究的是窗口内是否有重复字符，所以需要用left和map对应的键值idex进行比较，如果太过于久远，就得排除掉。如果已经重复了，那么我们必须移动比较远的一段，那么就是这个元素上次出现的下一个位置。
* 设重复元素为a1，a2。为什么不考虑a2-1位置时候的子串长度呢？因为我每一轮循环都会更新lenmax的值，如果上一轮没有触发重复的逻辑，那么lenmax自然也会更新，此时left为旧时的值。
* 这个题我没有掌握好滑动窗口的切入点，滑动窗口是一个动态的，不断加入和移除的过程。这里加入的是新的字符，移除的是重复字符之间的段。思考加入和移除分别对应的题目条件，我想下一次应该能做出来。

## 002号文件
### 01号题目
* leetcode.54.螺旋矩阵
* 采用动态边界的方法，每次遍历一条边都去观察一下对边界的影响，然后及时进行更新。边界相交就是退出循环的情况
* 这其实没有用到什么算法的思想，更像一类方法。当个知识点记住吧，螺旋类估计都可以这样做。

### 02号题目
* leetcode.383.赎金信
* 思路：我选择遍历字符串，每次遍历一个字符就去查找字典串并且删除一个，如果查找不到就退出循环。如果i没有>=长度，说明没遍历到底，那么就是没有构造成功，否则构造成功了
* 看到别人的解法：把字典串存储a[26]中分别对应每个字母出现的数量。目标串每遍历一个新的字符，对应位置的数值减一。如果有一个小于0，那么就匹配失败。4

### 03号题目
* leetcode.205.同构字符串
* 思路：开始的时候我没有注意到顺序不能变。其实很简单用两个hash表存入双向的映射关系，然后逐个字符匹配。后续的字符匹配不能违背前面已经建立好的映射关系。

### 04号题目
* leetcode.36.有效的数读
* 思路：本来我还高估了这个题目，实际上就是一个简单的模拟。用代码翻译题目要求就好。不过我还是做了一个字符转化为int的预处理，这样更符合我的思维习惯。题目不难，但是需要耐心

### 05号题目
* leetcode.48.旋转图像
* 思路：最简单的方法就是用一个临时数组存储题目给的数据，然后按列在原来的数据上进行修改
* 此外看到别人的思路：再我的行->列转换的规律之外，还总结了列->行的规律，综合这两点我们就可以总结点到点的规律。

### 06号题目
* leetcode.矩阵置零
* 思路：先遍历数组，记录存在0的行和列。然后再次遍历数组，根据我记录下来的情况对元素进行置零。没啥好说的，就是一个模拟题。

### 07号题目
* leetcode.289.生命游戏
* 思路：首先复制传入的数组，这样方便后面直接在原数组上进行修改。一个小技巧就是设置两个一维的数组，对应分别是x和y方向上八个位置的增减值。这样搜索的时候就比较方便。本质上还是个模拟题，要有耐心

### 08号题目
* leetcode.290.单词规律
* 思路：这个提和前面的同构字符串思路是一样的，就是构造映射。只需要吧后面那个长句子处理一下，用vector装下每一个单词就好。
* 不过这个题暴露了我很多细节不到位：循环中某些动作可能是会少一次的，设计上的缺陷导致我必须在循环外额外手动操作一次。然后就是find函数的结果要和end进行比较。以及一些简单的特殊情况判断，来防止越界访问之类的。这些细节以后都得加强注意

### 09号题目
* leetcode.242.有效的字母异位词
* 思路：用两个长度为26的数组，分别记录两个字符串中每一个字母出现的次数。然后对比两个数组内容是否完全一致就解决了。

### 10号题目
* leetcode.49.字母异位词分组
* 思路：开始我想借用前面字母异位词的方法。于是我就设置了一个二维vector vmap，来记录每一个分组的字母组成情况。每次遍历一个字符串，都去计算它的字符组成情况。然后在vmap中查找，看能不能找得到相同组成的vector。找得到就加入对应idex的答案二维数组中，找不到就尾插。虽然能过，但是太慢了，所以我选择弃用。
* 别人的优化做法：先用一个temp保存我们的目标数组，然后对temp进行排序，用排序后的temp作为hash索引，hash值是result中对应同构字符串的集合索引

### 11号题目
* leetcode.1.两数之和
* 思路：利用一个unorder_map<int,int>m。索引是x为了满足target还需要的值，键值是这个x在nums中的索引。这样不断更新的话就有记忆性了，进而遍历一遍数组就可以解决问题。

### 12号题目
* leetcode.202.快乐数
* 这个题可以用一个set记录每一次运算的数，如果在里面找到了自己，那么说明构成了环，否则最后会变成1.
* 看到别人用快慢指针的办法来优化。从结果上来看快慢指针确实快一些。

### 13号题目
* leetcode.219.存在重复元素二
* 思路：用一个unordered_map。里面保存的是同一个值最近一次出现的idx，随着遍历nums[i]的进行，不断更新和判断。如果到最后都没成功，那么说明不存在这样的解

### 14号题目
* leetcode.128.最长连续序列
* 思路：用一个set重构数组，然后读取其中的数x。如果x-1也在数组里面，那么无需处理。否则就让x自增知道set里面没有这个数，利用x自增后的值减去x的原本值然后和ans进行比较，取最大值。最后返会ans即可。
