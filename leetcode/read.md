# leetcode刷题
# 分类说明
* 其实我也没有什么好的分类方法，而且leecode上面是一个class一道题目，所以我干脆就一个文件放20道题目
## 001号文件
### 01号题目
* leetcode.122.买卖股票的最佳时机Ⅱ
* 思路：只要是上涨区间我就有利可循。所以可以采用贪心算法，先把所有区间分为一个个间隔为1的小区间，然后使用贪心算法对其进行求解

### 02号题目
* leetcode.55.跳跃游戏
* 思路：有一点点动态规划的意思，由于不确定中间最大跨越步数是多少，所以遍历一遍整个数组是必要的。设置一个最大跨越书rightmax初始化为0，然后每次变量一个数就进行更新，取max(rightmax,nunms[i]+i)。如果i比rightmax大，说明中间某一时刻已经无法覆盖当前的i了，直接返回false。如果最后rightmax>=size-1那么说明可以跳到最后一个格子。

### 03号题目
* leetcode.45.跳跃游戏2
* 思路：这个题目和第一个题目还是有些不一样。这次我们得去观察次数最少的情况。不过我们其实并不关心每一次跳到了哪一个格子，而是关心每一步的覆盖范围，覆盖范围之内就是一步的事情。所以在用rightmax给end赋值的时候，就可以大胆赋值了，因为一个范围内都是一步，随便调整路线最后用的步数都是一样的。每一次调整都要让步数自增，最后返回步数就好

### 04号题目
* leetcode.274. H指数
* 读懂题目就好说，所以我用一个数组记录每一个论文的引用数，然后倒序搜索，用累加和和最后的i进行比较

### 05号题目
* leetcode.380.O(1)时间插入、删除和获取随机元素
* 思路：其实是一个语法题，就当复习一下unordered_map和vector的使用了。不过交换到尾部再进行删除确确实实是一个不错的技巧

### 06号题目
* leetcode.238.除自身外数组乘积
* 思路：设计一个前缀数组和后缀数组，分别保存前缀乘积（不含自身）和后缀乘积，最后构造ans的时候两个数组对应相乘就好

### 07号题目
*  leetcode.134.加油站
*  思路：这个题目的关键在于油箱里面的油量在前往终点的途中不能小于0.这里可以在脑袋里想象一个折线图，横坐标是每一个点，纵坐标是加油量和耗油量的差值，然后我们希望做到的就是让这个折线图全部在x轴上方。然后再想一想，如果改变起点，折线的走势不会变，但是最终效果变成了折线整体的上下平移。但是折线上各个点的相对位置不会变。所以，为了让折线尽可能地向上平移，我们需要找到最低点，让它为起点。如果这样都无法满足条件，那么必然我们也无法回到起点。
  
### 08号题目
* leetcode.13罗马数字转整数
* 思路：一个模拟题，麻烦但是不难，使用一个unordered_mp就可以很好的解决

### 09号题目
* leetcode.12 整数转罗马数字
* 思路：其实还是一个模拟题，但是和前面相比要难一些。可以进行一个类比，我们是十进制有十个数字来表示，罗马数字也是特有的罗马进制，只不过他们的构成单位比较复杂而已。再想一想我们是怎么把十进制转换为其他进制的，这个时候就需要我们从高位开始减，直到减到不能减最终减到0位为止。这一题其实大概也是这个思路。就是一个数制转换

### 10号题目
* leetcode.56.最后一个单词的长度
* 思路：就是找出最后一个单词，不过需要注意一些细节。首先就是可能末尾有很多空格，也有可能是个字符只有一个的串。细节做好这个题就不难。

### 11号题目
* leetcode.14.最长公共前缀
* 思路：模拟题，首先排除存在空串、只有一个串的情况，然后遍历第一个串并且看其他串对应字符和第一个串是否相等，相等的话就把这个字符加入答案，否则就退出循环。

### 12号题目
* leetcode.151.反转字符串中的单词
* 思路:我希望遍历一遍字符串就把问题解决，所以我需要用continue来处理空格的细节，然后每个单词作为一个独立的字符串插入vector尾部，最后再拼接，并且插入合适的空格，就行了。
* 本题出错在于continue之前我没有改变i的值，导致超出内存范围

### 13号题目
* leetcode.28.找出字符串中第一个匹配的下标
* 思路：简单的话就用find，难一点的话用kmp，这个明天再看吧，因为有点困了懒得学东西
* string::npos可以理解为-1,用来判断是否有子串，而且find的返回值还得做一下类型强制转换

### 14号题目
* leetcode.392.判断子序列
* 思路：这是一道很不错的双指针题目，但是需要注意。遍历子串作为外循环，遍历母串是内循环，遍历母串的时候不能走回头路。如果母串走完了子串还没走完，那么就肯定不是了，否则就是。
* 没过的原因：每次匹配成功后没有吧j自增，导致j原地踏步，所以当有连续字符相同的子串出现的时候就会卡出而造成答案错误

### 15号题目
* leetcode.167.两数之和二--输入有序数组
* 思路：本题解法基础是双指针，但是却不是浅显的双指针。这一题由于解是一个二维坐标，实际上我们的搜索空间就是一个二维的，哪怕规定i和j的大小关系，也只能小一半的搜索空间。所以我们可以琢磨一下怎么去减少搜索空间。当a[i]+a[j]<目标如果i不动，那么比j小的都没有意义了。反之依然。一个1不动另一个移动，而不是两者同时动，这样可以做到搜索不漏。而不是简简单单的吧i和j分别只能自增自减随意套到解法中去，本质上还是要思考如何在合理的情况下逐步缩小搜索空间。

### 16号题目
* leetcode.11.盛最多水的容器.
* 思路：本题双指针还是要思考如何缩小搜索空间，指针每一次移动，都意味着排除掉了一个柱子。其实双指针的一般操作也可以给我们一些启发，一开始两个指针就放在两端。
* 在这个基础之上我们就可以分析每一次移动柱子对这个题目的影响是什么：首先每一次移动有一个是确定的，那就是减少了宽度。而且水面高度是由短柱子决定的，所以移动高柱子的话一定不会让结果更优，所以我们就只能去移动那根低柱子。直到双指针相遇，这个算法就停止了
* 之前思考出现过一些误区：我老是想着得到更好的收益，也就是说我希望我的移动让短柱子变成长柱子，这样才可能优化解。这种想法我觉得没错，但是我并不知道下一根柱子在哪里，如果在这纠结可能导致指针卡住。所以不妨放松一点条件，只要是短的柱子我们就可以移动。毕竟双指针某种意义上也是一种搜索算法，也就是会试探未知。

### 17号题目
* leetcode.7.Z字形变换
* 思路：咱们还是按行处理，遍历字符串的时候可以发现，行号先由0然后到n-1,再由n-1到0。所以我们利用这一点把字符串分到不同的行中，最后拼接起来即可
* 这个题我学到了一个flag的用法，初值的设置引起了我的思考。解题的时候一定是有限的，但是我们可以在无限的条件下思考初值该设置什么

### 18号题目
* leetcode.15.三数之和
* 思路：暴力三重循环也能做，但是不够优美
* 本题体现了我的双指针还是不够熟练。首先进行简单的数学分析，三数之和为0，那么说明最小值小于等于0，最大值大于等于0。为了方便，我们先对数组进行排序。这里我们不妨还是规定一下三个数的顺序，这遍历起来可以少干一些工作。首先确定最小值的位置，然后在数组后面部分进行双指针遍历。每一次得到解，或者每一次移动都需要让指针跳跃，直到不同的数值，以此来规避重复解。其它的也没什么好说的
* 双指针可以是整个题目双指针，也可以是某一步双指针，目前来说，双指针的本质就是减少搜索量，而这个减少的依据也就变成了移动指针的条件。所以要灵活应用

### 19号题目
* leetcode.209.长度最小的子数组
* 思路:这里采用的是滑动窗口的办法。首先我让快指针递增，直到sum比target大，然后再自增慢指针，减到sum恰好比taget小。直到遍历所有的元素

### 20号题目
* leetcode.3.无重复字符的最长子串
* 思路：这个题仍然用的是滑动窗口，但是我开始的时候没有想出来。首先如何确定字符串内没有重复元素？这里借助了一个unordered_map。运用查找函数就可以判断，当然我们的map没有移除元素的设计，那么如何判断某些元素已经不在了呢？这里我们想研究的是窗口内是否有重复字符，所以需要用left和map对应的键值idex进行比较，如果太过于久远，就得排除掉。如果已经重复了，那么我们必须移动比较远的一段，那么就是这个元素上次出现的下一个位置。
* 设重复元素为a1，a2。为什么不考虑a2-1位置时候的子串长度呢？因为我每一轮循环都会更新lenmax的值，如果上一轮没有触发重复的逻辑，那么lenmax自然也会更新，此时left为旧时的值。
* 这个题我没有掌握好滑动窗口的切入点，滑动窗口是一个动态的，不断加入和移除的过程。这里加入的是新的字符，移除的是重复字符之间的段。思考加入和移除分别对应的题目条件，我想下一次应该能做出来。

## 002号文件
### 01号题目
* leetcode.54.螺旋矩阵
* 采用动态边界的方法，每次遍历一条边都去观察一下对边界的影响，然后及时进行更新。边界相交就是退出循环的情况
* 这其实没有用到什么算法的思想，更像一类方法。当个知识点记住吧，螺旋类估计都可以这样做。

### 02号题目
* leetcode.383.赎金信
* 思路：我选择遍历字符串，每次遍历一个字符就去查找字典串并且删除一个，如果查找不到就退出循环。如果i没有>=长度，说明没遍历到底，那么就是没有构造成功，否则构造成功了
* 看到别人的解法：把字典串存储a[26]中分别对应每个字母出现的数量。目标串每遍历一个新的字符，对应位置的数值减一。如果有一个小于0，那么就匹配失败。4

### 03号题目
* leetcode.205.同构字符串
* 思路：开始的时候我没有注意到顺序不能变。其实很简单用两个hash表存入双向的映射关系，然后逐个字符匹配。后续的字符匹配不能违背前面已经建立好的映射关系。

### 04号题目
* leetcode.36.有效的数读
* 思路：本来我还高估了这个题目，实际上就是一个简单的模拟。用代码翻译题目要求就好。不过我还是做了一个字符转化为int的预处理，这样更符合我的思维习惯。题目不难，但是需要耐心

### 05号题目
* leetcode.48.旋转图像
* 思路：最简单的方法就是用一个临时数组存储题目给的数据，然后按列在原来的数据上进行修改
* 此外看到别人的思路：再我的行->列转换的规律之外，还总结了列->行的规律，综合这两点我们就可以总结点到点的规律。

### 06号题目
* leetcode.矩阵置零
* 思路：先遍历数组，记录存在0的行和列。然后再次遍历数组，根据我记录下来的情况对元素进行置零。没啥好说的，就是一个模拟题。

### 07号题目
* leetcode.289.生命游戏
* 思路：首先复制传入的数组，这样方便后面直接在原数组上进行修改。一个小技巧就是设置两个一维的数组，对应分别是x和y方向上八个位置的增减值。这样搜索的时候就比较方便。本质上还是个模拟题，要有耐心

### 08号题目
* leetcode.290.单词规律
* 思路：这个提和前面的同构字符串思路是一样的，就是构造映射。只需要吧后面那个长句子处理一下，用vector装下每一个单词就好。
* 不过这个题暴露了我很多细节不到位：循环中某些动作可能是会少一次的，设计上的缺陷导致我必须在循环外额外手动操作一次。然后就是find函数的结果要和end进行比较。以及一些简单的特殊情况判断，来防止越界访问之类的。这些细节以后都得加强注意

### 09号题目
* leetcode.242.有效的字母异位词
* 思路：用两个长度为26的数组，分别记录两个字符串中每一个字母出现的次数。然后对比两个数组内容是否完全一致就解决了。

### 10号题目
* leetcode.49.字母异位词分组
* 思路：开始我想借用前面字母异位词的方法。于是我就设置了一个二维vector vmap，来记录每一个分组的字母组成情况。每次遍历一个字符串，都去计算它的字符组成情况。然后在vmap中查找，看能不能找得到相同组成的vector。找得到就加入对应idex的答案二维数组中，找不到就尾插。虽然能过，但是太慢了，所以我选择弃用。
* 别人的优化做法：先用一个temp保存我们的目标数组，然后对temp进行排序，用排序后的temp作为hash索引，hash值是result中对应同构字符串的集合索引

### 11号题目
* leetcode.1.两数之和
* 思路：利用一个unorder_map<int,int>m。索引是x为了满足target还需要的值，键值是这个x在nums中的索引。这样不断更新的话就有记忆性了，进而遍历一遍数组就可以解决问题。

### 12号题目
* leetcode.202.快乐数
* 这个题可以用一个set记录每一次运算的数，如果在里面找到了自己，那么说明构成了环，否则最后会变成1.
* 看到别人用快慢指针的办法来优化。从结果上来看快慢指针确实快一些。

### 13号题目
* leetcode.219.存在重复元素二
* 思路：用一个unordered_map。里面保存的是同一个值最近一次出现的idx，随着遍历nums[i]的进行，不断更新和判断。如果到最后都没成功，那么说明不存在这样的解

### 14号题目
* leetcode.128.最长连续序列
* 思路：用一个set重构数组，然后读取其中的数x。如果x-1也在数组里面，那么无需处理。否则就让x自增知道set里面没有这个数，利用x自增后的值减去x的原本值然后和ans进行比较，取最大值。最后返会ans即可。

### 15号题目
* leetcode.228.汇总区间
* 思路：用一个last指针和一个now指针去寻找连续片段。如果nums[last] - nums[last-1]！=说明连续区间断了，就加入到答案。然后now变成last，last继续向前逐一递增
* 没过的原因：在for外部声明的now 被 int now覆盖了，然后就是测试用例有一个int的最小负数，作差之后溢出了。所以在条件判断的时候要强制转化成long

### 16号题目
* leetcode.56.合并区间
* 思路：首先先按照左端点进行一个从大到小的排序，然后从左往右一次插入数值对。如果result是空的或者interval[i][1]>result.back()[1]。说明当前区间没法和已有区间重叠，就得push_back。否则就插入到最后一个区间，并且更新最后一个区间的右端点，取最大值。
* 因为最开始有排序这个动作，所以我新插入的区间如果能插入，一定是插入的尾部的区间，不可能说还能插入中间的区间
* 没做出来的原因：开始的时候没有想到排序，然后有些误解了重叠区间的意思

### 17号题目
* leetcode.57.插入区间
* 思路：其实完全可以借用上一题的方法，就是吧新的区间插入然后再运行一遍代码。
* 另外的思路：当插入的这一个区间可以将我们原来的interval分成三类，一类是所有元素比区间元素小，一类是所有元素比区间元素大，最后一类是区间元素和插入的区间有交集的区间。第一类和第二类可以直接压入答案，需要处理的是中段。中段是一个不断合并更新的过程中，取两个区间中最小的左端点为左端点，取两区间中最大的右端点为右端点，直到不再有变化。最后把剩下的区间压入result即可

### 18号题目
* leetcode.452.用数量最少的箭射爆气球
* 思路：首先按照区间右端点进行排序，然后每一次设在区间右端点上，记为pre。如果后续的区间左端点大于等于pre，那么说明也被射爆了，不用管它。否则的话就要更新pre，并且把箭的计数自增一下。
* 没想出来的原因：开始的时候是有一些排序后射在右端点的想法，但是我开始想的排序方法是用左端点排序，这种情况下是不合理的，因为此时射在右端点并不能保证射出来的箭是最少的。所以用端点排序的时候要仔细思考哪一个端点才是更合理的，暂时没法总结一个合理的规律，那么就都试一试
* 此外还学习了lameda表达式的写法，sort函数还是很方便用到的

### 19号题目
* leetcode.20.有效的括号
* 思路：其实就是考察stack知识点的使用。首先可以先创建一个unordered_map存储每一对括号，然后遍历到左括号入栈，遍历到右括号出栈，不匹配就是false
* 注意，最后栈要是空的，要不然也不对

### 20号题目
* leetcode.71.简化路径
* 思路：题目标签是栈，但是我实际上并没有用到栈的知识。首先创建一个vector<string>strs,遍历输入字符串path。跳过'/'，如果是"."就不管他，如果是".."并且strs非空，就删掉上一个进入strs的string。其它的全部进入strs，最后配合'/'，拼接一个符合题意的字符串即可，其实效果还不错
* 别的思路其实也大差不差

## 003号文件
### 01号题目
* leetcode.155.最小栈
* 思路：这个题目是从别人那里学习的。第一版是除了stack之外还维持一个最小栈，只要入栈元素比最小栈栈顶元素小，才会入最小栈，否则忽视。所以如果需要查找最小值，只需要返回最小栈的栈顶元素。当栈中元素被弹出并且等于最小栈的栈顶元素的时候，最小栈也要弹出栈顶元素
* 第二版本的最小栈变成了一个int min。存储当前最小值。入栈的时候如果入栈元素x，小于当前min。那么先把min压入栈，再把x压入栈，最后把min赋值为x。出栈的时候如果栈顶元素等于min，那么还需要额外pop一次，这次pop的是之前压进去的旧min

### 02号题目
*  leetcode.150.逆波兰表达式
*  思路：考察栈的使用，逆波兰表达式的基本知识。其他的可以当做模拟来做。
*  逆波兰表达式：用栈来翻译：遇到数字入栈，遇到运算符出栈两个数字，第一个是右操作数，第二个是左操作数。然后吧计算结果又存回栈，最后栈顶元素就是表达式的结果
  
### 03号题目
*  leetcode.141.环形链表
*  思路：使用快慢指针，如果存在环形，那么快慢指针一定会相遇，否则就是没有环
*  不过链表中有些小细节我不是很清楚，别人的答案值得一看

### 04号题目
* leetcode.2.两数相加
* 思路：其实就是同时遍历两个链表，然后每一位算出来后都分配一个新的结点，没什么难度其实
* 学习到的东西：哨兵结点，是虚拟的，最后不返回，但是可以方便我们操作

### 05号题目
* leetcode.21.合并两个有序链表
* 思路：其实类似归并排序，这里用了一下哨兵节点，很方便

### 06号题目
* leetcode.138.随机链表的复制
* 思路：每次除了深拷贝一个节点，还记录每一个节点的random节点距离head的距离。这样的话后续就可以更新random
* 别人的思路：一种是用hash表记录原节点到新节点的映射
* 别人的思路：不用hash表。将新分配的节点直接插到原来对应节点之后，然后根据这个新的链表来构建random关系，最后分离两个链表
* 值得一看--链表的分离：https://leetcode.cn/problems/copy-list-with-random-pointer/solutions/2993775/bu-yong-ha-xi-biao-de-zuo-fa-pythonjavac-nzdo/?envType=study-plan-v2&envId=top-interview-150

### 07号题目
* leetcode.92.反转链表
* 思路：本题考察链表的知识，尤其是修改链表指针的知识。这里还是采用哨兵节点，解决一些边界问题。好好掌握这些细节吧

### 08号题目
* leetcode.19.删除链表倒数第n个节点
* 思路：反正我是用哨兵节点和一个栈就很好实现了，找到目标节点，然后修改pre和next的关系就可以做到
* 第一遍没过的原因，找结点的时候pop次数不对，想不清楚的话以后画个图就好
* 别人的思路：先让快指针走n步，当快指针是尾结点的时候，慢指针正好是目标节点的前一个节点

### 09号题目
* leetcode.82.删除排序链表的重复元素二
* 思路：还是要用哨兵，这是我学别人的删除方法，每次删除一个近处的节点，把一个远的节点拉回来，这样就更加符合循环条件
* 哨兵确实好用，而且一般使用哨兵cur就是从哨兵开始，所以这个解法中直接去更加关注了next和next->next。而不是关注cur本身

### 10号题目
* leetcode.61.旋转链表
* 思路：参照前面用快慢指针。不过先遍历一遍，看链表长度。然后k对这个长度取余数，这样可以减少不必要的计算。然后先让快指针走k步，快指针到结尾的时候，慢指针的下一个元素会变成头，慢指针本身会变成尾部。所以slow->next是nullptr。原来的尾部要指向原来的头部

### 11号题目
* leetcode.86.分隔链表
* 思路：开始的时候我想用两个栈或者队列，但是后来想根本不需要。只需要两个哨兵dims,dimb分别指向比x大的链表部分和比x小的部分以及对应的两个pres和preb指针分别初始化为哨兵。遍历链表,当结点的val比x小就放入dims那一条，然后更新pres。否则放入dimb。最后调整pres指向dimb->next。以及调整preb->next指向nullptr。返回值是dims->next。就可以了

### 12号题目
* leetcode.146.LRU
* 思路：主要是学习别人怎么处理这个问题的
* 首先private里面要放什么：容量、键值和结点的hash表、头尾结点，以及移除函数、头插入函数，转移到头部的函数
* 这里转移函数的存在告诉了我们没有在移除函数和头插入函数中进行内存的分配和释放
* 然后就是双向链表的使用，要时时刻刻想到会不会是头和尾部
* 最尾部的节点是最久没访问的，转移头部函数是让某一个被访问的节点转移到链表头部

### 13号题目
* leetcode.104.二叉树的最大深度
* 思路：一个简单的递归函数，子树最大深度+1就是最大长度。

### 14号题目
* leetcode.100.相同的树
* 思路：层序遍历，然后注意好细节。从这个题目暴露出我写代码的条理性不够
* 当你觉得if的条件很难写的时候，可以先写一个if排除一些情况（有return这样的语句）再写下一个逻辑不那么准确，但是一定正确的if语句
* 别人的写法：递归写法，非常简介，dfs

### 15号题目
* leetcode.226.翻转二叉树
* 思路：我采用的是递归，先左右子节点交换，再分别在左右子节点上调用递归函数
* 别人的做法：层序遍历，利用一个队列。然后对于每一个节点都去交换它的子节点。其实本质上就是一样的

### 16号题目
* leetcode.101.对称二叉树
* 思路：先参考前面的题目：相同的树。我还是使用了层序遍历法。两个子树分别有一个队列，但是两个子树的左右子节点入队列的方式正好是相反的，所以只要遍历下来时时刻刻相同那么就正好是对称的
* 别人的做法：还是用递归，但是需要辅助函数。辅助函数是一个递归函数，但是传入的参数是二元的，对称地去分析两颗子树的对应位置。这个时候两个子树其实作用是相互独立的，彼此相互比较。

### 17号题目
* leetcode.105.从前序与中序遍历构建二叉树
* 思路：首先我们抓住这两个序列的关键点：每一段前序序列的第一个元素必然是根节点，我们可以根据这个根节点对某一段序列进行左右子树的划分，并且在已知边界的情况下分别知道左右子树的序列长度
* 这是一个递归的过程，也就是说我们在写函数的时候要思考怎么去表达这些条件
* 学习别人的做法：首先用一个hash表，记录每一个节点在中序序列中的位置索引。为什么？我们需要利用中序序列的索引来确认左右子树的序列长度。
* 递归函数的传参：root 是本次递归要处理的节点在前序序列中的索引，left是我们考察的序列（中序的左边界）,right是我们考察的序列的右边界。
* 每一层递归都需要处理一个root，对于这个root来说，它是传入的中序序列[left,right]中的根节点
* 那么显然，我接下来需要处理root的左节点以及root的右节点，它们分别是左子树和右子树的根，自然而然我需要划分这个中序序列。
* 去掉root之后，root+1必然是前序序列中左子树的根节点
* 再去查找root在中序序列中的索引i，我们就可以知道左子树的中序右边界是i-1（此时要去掉根节点），右子树的左边界是i+1。此时可以计算出左子树的长度，然后根据这个长度和左子树前序序列索引root+1，就可以计算出右子树根节点索引。
* 此时左子树和右子树都处理好了，递归函数完毕
* 首先思考为什么实际划分是按照中序来划分的：这比较符合我们的习惯，中间切一刀，前序划分的话如果找不着右子树的根节点，真的不好划分。所以我们考察的是中序序列，也就需要中序序列的左边界和右边界
* 那么这个root是干啥的？root是为了确认根节点在中序序列是哪一个，在前面的分析中，我们需要依靠前序序列来确认根节点，所以这里传入的根节点就成了前序序列的索引
* hash表的存在是为了快速确定中序序列中根节点的位置。
  

### 18号题目
* leetcode.112.路径综合
* 思路：其实就是递归，再叶子结点进行判定，叶子结点的值必须等于targetsum，每次往下传递的时候targetsum = targetsum-结点键值。左右子树只要一个满足条件即可

### 19号题目
* leetcode.129.求根节点到叶节点数字之和
* 思路：如果这个题目不允许使用辅助函数或者辅助的全局变量，我会觉得是个非常难的题目，所以我用了一个辅助函数。函数的参数多了一个变量x，用于保存上层的路径数。然后写好递归函数，注意边界条件就好
* 对于递归返回的逻辑条件还是不够清晰

### 20号题目
* leetcode.117.填充每个节点的下一个右侧节点指针II
* 思路：我这里用了一个队列q，以及一个vector<int>nums，还有一个dimmy哨兵（每一层last初始化为dimmy）。遍历的思想是层序遍历，nums用来记录每一层节点的数量。有一个内循环，就是每一层节点的遍历，这个过程中不仅会更新next指针（只要指向下一个就好），还会记录每一层的子节点数来更新vector。
* 别人的思路：深度优先算法，遍历到当前深度的时候，pre[depth]->next = cur。然后更新pre[depth]为now

### 21号题目
* leetcode.106.从后序与中序遍历构建二叉树
* 思路：看前面的前序和中序，代码几乎是一样的，只不过是结合了后序遍历的逻辑

## 004号文件
### 01号题目
* leetcode.114.二叉树展开为链表
* 思路：我设置了一个class的成员队列，然后利用按照先序逻辑的递归，填充这个队列。最后出队的时候把每个左指针置为null，右指针置为队列中下一个节点既可以了
* 别人的思路：由于二叉树的结构性质，而且要求是先序遍历。我们可以把右子树移动到左子树的最右节点，这样不会改变遍历的结果。然后把左子树移动到右子树的位置，直到最后右子树为空就做完了
* 别人的思路：这里还有一种非常巧妙的思路，先序遍历是 根、左、右。 这里逆向思维先右后左再根，形成了一种倒着穿珠子的办法。设置一个全局的pre，就是指向上一个被处理的节点。由于根节点左节点是nullptr，所一上一个处理的节点就一定是这个右子树。然后这棵树做完之后，根节点也变成了上一个处理的节点。

### 02号题目
* leetcode.222.完全二叉树的节点个数
* 思路：我一开始就是一个二叉树的递归算法，很简单但是和完全二叉树没有任何关系
* 别人的思路：首先分析完全二叉树的性质。如果左子树的深度和右子树是相等的，那么左子树一定是满的，如果左子树大于右子树的深度，那么右子树是满的只不过少一层罢了。根据这个性质，再配合位运算我们就能很快的把题目解决。

### 03号题目
* leetcode.173.二叉搜索树迭代器
* 思路：利用一个栈，中序遍历用栈是比较合适的。只要左子树不空，那就都入栈，弹出的时候看弹出的节点右节点是不是空的，如果不是，把这个弹出的节点在走一遍“左子树不空，那就都入栈”每次next就弹出一个节点，hasnext则是看这个栈是不是空的。

### 04号题目
* leetcode.236.二叉树的最近公共祖先
* 思路：首先设计一个fs函数，确认两个节点是否有父子关系。如果f遍历可以找到s那么就有。然后用一个栈和一个辅助栈，来让栈里装入先序遍历序列。如果q和p有父子关系，直接返回其中一个，否则就从我们的先序序列中逐个弹出，直到找到p和q的公共祖先。找到了一定是深度最深的，这是由先序遍历的性质决定的
* 看看别人的：有一种分治的思想。首先我们分析一下这个问题，如果root（代指某一个节点）是p和q的最近公共祖先，要么p或q==root，要么p和q在左右子树。找到了p或者q就返回，这样的话返回值一定都是最小祖先或者pq本身。还是很精妙的一种算法。
* 注意：如何保证返回的东西是最近祖先，最近祖先是某个子树的根节点，另一侧子树是nullptr，然后递归地想这个问题就可以明白了，每次都会删去一颗子树留取另一颗子树，到最后就是最近的祖先了
* 如果left和right都不空，那么说明root就是答案，

### 05号题目
* leetcode.200.岛屿数量
* 思路：dfs，如果某一个元素是1，那么就让它变成0，然后再四个方向都进行dfs。外面有一个循环遍历字符数组，每使用一次dfs就cnt++；最后返回cnt
* 别人的思路：bfs:前面变成0，是一样的，不过它会借助一个队列，每次弹出一个1元素，会把四个方向的元素个push进去
* 一点小技巧：可以不把判断条件写的那么复杂，而是在函数本身确定这次函数的参数值是否合法，至于下一次嘛，交给下一次的函数去判断，这样代码量可以少很多

### 06号题目
* leetcode.102.二叉树的层序遍历
* 思路：前面有一道题我学习到了深度优先算法，见三号文件20题，这里我进行了一个类比，在depth相同的时候pushback，能过。但是我忘记了当第一次进入一个depth的时候需要先创建一个空的一维vector
* 别的思路:这个其实是对我前面第20题自己思路的优化，广度优先。我没有想到队列大小和层中节点数量的关系，想明白这个之后就很简单了

### 07号题目
* leetcode.199.二叉树的右视图
* 思路：嘻嘻，一招鲜吃遍天。就是上一题的bfs，只不过答案只需要保存每一层的最后一个元素

### 08号题目
* leetcode.637.二叉树的层平均值
* 思路：不好意思呢，还是bfs

### 09号题目
* leetcode.103.二叉树的锯齿形层序遍历
* 思路：总体上还是bfs，设置一个bool开关，每遍历一层就翻转一次，根据这个开关决定要不要把临时的vector翻转，然后再加入答案中
* 别人的思路：用了一个双端队列可以头插也可以尾插，那还不如一个栈加一个队列呢

### 10号题目
* leetcode.530.二叉搜索树的最小绝对差
* 思路：刚开始的时候我还是用了层序遍历，然后对数据进行排序。实际上这是不好等等，因为搜索二叉树的中序遍历是一个单调递增序列，有了这个知识点，只需要完成层序遍历序列就可以了

###  11号题目
* leetcode.230.二叉搜索树中第K小的数字
* 思路：中序遍历，保存结点的值，当vector的大小是k的时候，返回最后一个插入的值
* 看看别人的：也是这个思路，中序遍历，不过别人用的是递归写法。用一个成员k来计数，之前我一直害怕对递归的技术，其实没什么可怕的

### 12号题目
* leetcode.98.验证二叉树
* 思路：中序遍历，把键值保存在vector里面，最后检查是否是一个升序序列。另外一种写法就是递归写法，不过要声明一个成员变量pre用来保存上一个结点的值。
* 其它思路：前序遍历，不过稍微改造一下传入的参数，有左边界和右边界。每个节点的值x都必须在左右边界范围之内，然后x作为左子树的右边界和右子树的左边界传递下去

### 13号题目
* leetcode.130.被包围的区域
* 思路：可以观察到，如果不被包围，那么这一块连通图必定至少有一个方块在边界。所以我就扫描一次边界，对里面所有的O块进行一次bfs，标记联通的O为true。然后如果没有标记为true的位置，那就最后要被填成'X'。
* 看看别人的：思路一样的，不过可以用dfs写法，没有使用队列罢了

### 14号题目
* leetcode.133.克隆图
* 思路：前面有做过复制链表的题目，我因此得到启发。核心思想是用一个hash表把旧节点和新节点之间的映射关系存储起来。首先用一个队列，和一个vector pre，来存储整张图的节点。每次入队的节点都确保没有在pre之中。当旧图被保存在vector之后，我们就一个个分配节点并且构建映射关系，然后再遍历一次，构建新图之间的邻居关系。
* 看看别人的:别人使用了比较明确的dfs和bfs写法，这个我得好好学习一下。其实我用的似乎也是bfs但是代码不够简洁。

### 15号题目
* leetcode.399.除法求值
* 思路：这个题目的思路我从没有想过，所以直接看答案了。需要再消化一下，有点晕了。

### 16号题目
*  leetcode.208.实现前缀树
*  思路：这个题目当个补充知识点来看待吧，基本操作就是这一些了。可以好好看一下。

### 17号题目
* leetcode.211.添加与搜索单词
* 思路：开始的时候没看题目，发现字符串里面也有'.'。由于字符串本身的性质，所以在别人的提示之下，我使用了dfs
* dfs终止的节点，到字符串结尾了，或者节点是nullptr。前面一个情况是由字符串决定的，后面一个条件其实更加符合字典树的性质。
* 如果不是'.'，那就是一个简单的前缀树，这里和前缀树的处理是差不多的。但是我是在dfs中使用，所以只需要传入对应的next节点，并且吧start向后移动一位就可以了
* 如果是，那么可能性就非常多了，每一个next数组中非nullptr的元素都可能是答案，当然也有可能没有答案，所以这里需要一个循环，对每一个非null节点进行dfs。只要有一个dfs成功了，我们就可以返回true了
* 如果前面没有结果，那么最后只能返回false了。

### 18号题目
* leetcode.17.电话号码的组合
* 思路：不太记得回溯模版怎么写了，所以做这个题有点不知所措了，从这里大概知道了回溯该怎么写，继续联系吧。

### 19号题目
* leetcode.77.组合
* 思路：本题我又没有做好，因为我忽视了一个重要的动作，那就是恢复状态。为什么上一题不需要恢复状态，因为上一题不存在某一个空位选不选的问题，必须有一个选，然而我的循环展开其实已经相当于去恢复状态了。
* 恢复状态是很重要的，就是恢复状态才能有不同的组合
* 另外一种写法就是枚举可以选的数，这种写法和我们前面的思维还不太一样。直接枚举可以选的数，从start开始，到n-k+1结束，为什么？首数字不能选的太晚，否则数会不够用
* 然后选好了第一个位置就选后面一个位置，后面还是要恢复状态的。
  
### 20号题目
* leetcode.77.全排列
* 思路：还是回溯。如果剩余要排元素个数为0，那么可以将path放入ans，并且返回。否则用一个循环，来枚举可以下一个放入的元素，这里是否可以放入还借助了一个bool数组flag来标记是否被占用了。每次放完一个元素dfs之前，要把元素对应位置上的flag置为false，然后恢复现场的时候除了path进行pop_back，还要吧对应的flag变回true;
* 不过下次可以把一些元素放入成员内部，当然不放也行


## 005号文件
### 01号题目
* leetcode.9.回文数
* 思路：如果是负数直接返回，如果是正数，把它变成字符串，然后头尾指针同时遍历，如果有不相等就返回false。否则到最后就返回true
* 不好意思哈哈，今天做不完12题，拿来凑数
* 当然也可以先算倒序值，最后和原值进行比较

### 02号题目
* leetcode.39.组合综合
* 思路：其实还是几乎一样的dfs模版，只需要对选择的集合进行排序，然后每一次dfs的时候都保证我们的path序列是单调不减的就可以了。然后最好做一下剪枝

### 03号题目
* leetcode.22.括号生成
* 思路：简单的dfs，不过要时刻注意我们填入的右括号不能比左括号多
* 别人的思路：枚举下一个右括号的位置

### 04号题目
* leetcode.79.单词搜索
* 思路：还是dfs，不过由于前面已经做习惯了有个path，这种不应该带path的反而做不出来了哈哈。我们dfs的过程其实就是串匹配的过程，所以传入要搜索的点在board中的坐标(i,j)。以及已经搜索的深度k。如果i、j越界，或者board[i][j]!=word[k]。那就return false。如果k==word.length()-1.说明搜索成功，不需要继续搜了，直接返回true。否则就需要在四个方向继续搜下去，只要有一个方向的返回值是true，最后的答案就是true。

### 05号题目
* leetcode.207.课程表
* 思路：这个题目本质上是看这个课程表中对应的图有没有环，考查了拓扑排序，以及深度优先对环的处理。这些知识点我不是很熟悉，所以要好好学习一下。
* 拓扑排序法：首先了解拓扑排序算法的流程，一步步移除入度为0的节点并且删除这些节点指向其它节点的边直到删除所有节点。如果无法删除所有节点，那么就说明了有环的存在。首先我们读取整个课程表，然后构造一个vector<vector<int>> graph和 vector<int>indegree。graph存的是每个节点的后继，indgree存的是每个节点的入度。这样其实就以比较小的空间存储了整个图。然后第一遍扫描，把入度为0的节点入队，然后进行bfs搜索，每出队一个结点，taken+1表示可以上一种课，然后它们后继节点入度-1，并且把入度减为0的节点放入队列。如果最后taken等于课程数，说明没有环
* dfs三色标记法：分别用0、-1、1表示未处理、已处理和处理中。我们的目的是检查路径是否有环，这个和前面的恢复现场不太一样。如果已处理，那就直接返回true，如果是处理中，说明我们两次访问了这个节点，那么必然是有环的，否则就遍历这个节点的后继。dfs遍历后继，如果没出问题，那这个节点算是完全遍历完了，把它标记为-1再返回

### 06号题目
* leetcode.210.课程表2
* 思路：我选用的是拓扑排序，和上一题不同的是，每一次pop一个结点，我都会把这个节点放入ans中去
* 这里让ai写了一个搜索全部序列的方法，拓扑排序是不可行的，留着看看吧。其实和以前的path差不多，只不过恢复现场的时候有点不一样

### 07号题目
* leetcode.909.蛇梯棋
* 思路：首先我们初始化一个vector<bool>visited(n*n+1),用来标记某个节点是否被访问过。用一个step来记录我们的当前路径长度，每处理一层step+1一次，就像一个个同心圆。每一层一个循环，每出队一个元素，判断是否为最终节点，如果是就直接返回。否则的话，遍历1~6号节点，如果没有访问过就入队。当然这个过程中，我们需要判断行列坐标，利用除法和模运算。如果行数为奇数，列数就需要翻转。行数一定要反转，然后处理一下是否有蛇梯。
* 这个题我开始没啥想法，但是这个题目让我对bfs有了更深刻的认识。当第一次访问到目标节点，此时路径一定是最小的

### 08号题目
* leetcode.433.最小基因变化
* 思路：这题我想了很久，虽然做的不够优美，但是好歹做出来了。首先我得确定start和end是否在bank。如果end不在bank那么一定是完成不了的，如果start在bank我需要把它去掉。然后确定end在bank的位置，start是0号节点，后面bank里的字符串按顺序排列，把这些字符串都抽象成一个个节点，然后就变成了0号节点到end节点的路径。初始化一个visit节点内容为false，长度为所有节点的个数。然后设置一个graph用来保存边，如果两个字符串只相隔一个数字，那么它们之间就有两条边。剩下来的问题和前面课程表蛇梯棋是一样的了。代码还比较长，虽然内存开销大，但是速度确实不错
* 看看别人的： 其实思路是大差不大的，只不过别人是动态更新，没有用graph把边存下来，这样的好处是可以减少内存，但是计算量和我的思路是一样的。这体现了别人bfs还是更加深刻和熟练

### 09号题目
* leetcode.108.将有序数组转化为二叉数组
* 思路：可能是前面回溯搞得太多了，这么简单的dfs居然不会写了
* 每一次dfs只分配一个结点，作为根，子结点交给下层dfs分配
* 如何处理中点，或者说中点的计算

### 10号题目
* leetcode.148.排序链表
* 思路：这次又恶补了一个只是点，分支归并排序法。
* 我们之前常做的是数组，所以切分起来就比较方便。如果切分链表呢？这里采用的是快慢指针的方法 slow = head,fast= head->next。每次slow移动一位，fast移动两位。所以这个时候我们反过来思考返回条件，一个是head==nullptr，一个是head->next==nullptr。其实也很合理
* 当我们找到中段结点之后，需要断开链表，slow->next就置为nullptr。这个时候我们设置一个哨兵节点dummy。cur = dummy。然后分别对left 和right进行递归，递归的目标是断开的两段链表
* 然后对排好序的left以及right进行归并排序
* 最终返回值是dimmy->next
* 这是个模版，好好背一下就行。

### 11号题目
* leetcode.53.最大子数组和
* 思路：先去好好学一下kadane算法，这就是kadane算法的模版，当然也可以把它当动态规划做
* 动态规划最重要的是思路，但是怎样才能有思路呢？我觉得还是需要一些题目的积累作为背景，就像高中数学物理的二级结论那样

### 12号题目
* leetcode.918.环形数组的最大和
* 思路：首先我的思路是把这个环型拆开，不同的元素做最后一个元素，然后用前面的最大子数组和。这个其实在小数据范围是正确的，理论其实也是正确的，因为最后的答案无非就是某一种拆分
* 但是我TLE了，这种做法的时间复杂度太高，数据量一大就无法过
* 别人的做法：从最后的答案分类入手，一是答案子数组没有在两端，那么就是前面的最大子数组和。另外一种是在两端，由于整个数组的和是一定的，所以此时如果中间部分的子数组和和最小，那么我们的两端子数组和就最大。所以我也设计了一个最小子数组和的函数。但是，如果最小子数组是整个数组，那么就就不行了，返回值是空数组，这是不合理的。所以这种情况下，submin =sum的时候我们也要返回submax。 否则就是返回max(submax,sum-submin)。

### 13号题目
* leetcode.35.搜索插入位置
* 思路：二分查找法，细节随小，乾坤很大
* 我最后选择了我粘上来的这种写法
* 首先从赋初值开始，就按时了我们搜索的区间[left,right)是一个左闭右开的区间[0,nums.size()];
* 然后我们的循环条件是left< right，这其实也是二者无法相等，还是左闭右开
* 在移动的时候，如果nums[mid]< target。left变成mid+1,这里也说明了nums[left]是可以访问的。
* 如果nums[mid]> target 。right变成mid，这里说明了nums[right],是不会被访问的
* 最后返回left也合情合理，因为左闭右开区离散间压缩到极致的时候就只有左端点可以取值

### 14号题目
* leetcode.427.建立四叉树
* 思路：dfs，方块区间划分。这是一个不错的模版。要注意好方块划分边界的计算
* 别人的思路：二维前缀和来优化
* presum[i+1][j+1]=presum[i+1][j]+presum[i][j+1]−presum[i][j]+grid[i][j]，这是构造二维前缀和的公式
* 求子矩阵[x0,x1)*[y0,y1):sum=presum[x1][y1]−presum[x1][y0]−presum[x0][y1]+presum[x0][y0] 其中[x0,y0] 是左上角，[x1,y1] 是右下角（不包含）
* 前缀和天然适合左闭右开区间

### 15号题目
* leetcode.74.搜索二维矩阵
* 还是二分法。不过这次要把这个二维矩阵虚拟化为一维，利用好触发和模运算就可以映射节点编号和坐标
* 注意细节，二分结束的时候left = right = mid。同时在检查查询结果是否等于目标之前，我们要检查一下left是否还小于m*n

### 16号题目
* leetcode.162.寻找峰值
* 思路：二分法。由于题目告诉我们了，nums[-1]和nums[size]可以看做负无穷，那么就必定是有峰值的，而且题目只需要我们找到一个峰值，那么就可以用二分了。比较num[mid]和num[mid+1]。如果左边大，说明mid已经处于下坡了，所以峰值在左段，更新right为mid。否则更新left为mid+1。
* 这个题目引发了我的思考二分的本质是什么？
* 之前就是简单的认为，是一个在单调序列上的查找。但是其实本质是筛去一半的样本，初始的模版是大差不差的，有left、right、mid。问题就在于我们如何去找到每次筛去一半的条件。之前的条件是筛去的数值不满足条件，这次是保留的一半可以满足条件。这个得慢慢体会

### 17号题目
* leetcode.33.搜索旋转排序数组
* 思路：每次[left,mid) 和(mid,right]一定是一个有序的，检查一下是不是在有序这一边，然后就可以移动左右了
* 二分法其实也要找某种有序的区间，有序往往意味着大胆删除
* 有点烦，不同的写法取不取等还有讲究

### 18号题目
* leetcode.34.在排序数组中找到同一个元素的第一位和最后一位
* 思路：二分，这里我采纳了开区间二分。lower_bound。找第一个，或者下一个元素的第一个，然后end-1就行了
* 得好好比较一下三种二分写法，二分思想不难，但是这些小细节很麻烦

### 19号题目
* leetcode.153.寻找旋转排序数组中的最小值
* 思路：放一会儿很烦

### 20号题目
* leetcode.66.加一
* 思路：太简单了，略

## 006号文件
### 01号题目
* leetcode.70.爬楼梯
* 思路：对于a[n]有两种办法来到这个点，一是n-1跨一步，一是n-2跨两步。这样我们就弄好了递推公式，然后解决就行

### 02号题目
* leetcode.198.打家劫舍
* 思路：同样的三个相邻之间的有关系.dp[i]表示前i家最大偷取金额，dp[n+1],dp[n],dp[n-1]。对于dp[n+1]，如果这一家不偷，那就相当于dp[n]。如果要投，那么就不能去偷n，所以就有公式
* ans[i] = max(ans[i-1],ans[i-2]+nums[i]);

### 03号题目
* leetcode.172.阶乘后的0
* 思路：由于偶数的数量远远大于5的数量，所以0的数量就是5的数量
* 需要注意的是，像25这样的数会贡献两个5，所以内循环的条件是 temp%5==0;

### 04号题目
* leetcode.69.x的平方根
* 思路：牛顿二分法，看看得了。

### 05号题目
* leetcode.50.pow(x,n);
* 思路：快速幂算法：由于我们可以把幂看做一个二进数，然后就是x的2的幂次方的乘积。所以每次移位，如果最低位是1就把res和当前x相乘，每一次移位x都要变成自身的平方。这样就把时间复杂度降到了logn

### 06号题目
* leetcode.215.数组中第K个最大元素
* 思路0：快速排序然后返回倒数第k个元素
* 思路1：快速选择算法，运用的是分治的思想。每一层，我们随机选取一个哨兵，把数组中的数据变为三类：big small equal。然后判断k在哪个范围内，如果在big范围内，子函数传参为（big，k）如果在small，子函数传参为(small,k-nums.size()+samll.size())。否则就返回哨兵
* 思路2：堆排序，slt有一个优先队列，就是用堆来做的，看看就行。如果不需要我去构建这个堆，那这个题目确实很简单


### 07号题目
* leetcode.373.查找和最小的k对数字
* 思路：构建一个tuple<sum,i,j>。分别表示对的和，以及对分别在1、2中的位置。然后构建这个tuple的优先队列，要小顶堆（默认是大顶堆）。然后初始化所有的<sum,i,0>进入堆，每次弹出堆顶<sum,i,j>就放入答案里，往队列加入<sum,i,j+1>。最后答案就是我们要找的最小的k个对
* 为什么这样能行，如果我们弹出一个<i,j>。那么对于这个<i,j>来说，我要优先考虑的是<i+1,j>和<i,j+1>。因为这两个对一定是离他最近的，但是如果每次弹出我都把这两个入队，就一定会有重复。因为<i-1,j>和<i,j-1>后续元素和<i,j>的后续元素是有交集的。所以我们不妨规定只会让<i,j+1>入队，那么形如<i,1><i,2><i,3>......的都会入队，所以初始化所有的<sum,i,0>入队，让每个对都有机会候选
* 其实如果构造一个二维数组matrix[i][j] = nums1[i]+nums2[j]。我们会发现每一行都是单调递增的，所以我们入队的是每一行当前剩余的最小元素，那么所有剩余元素的最小元素必然也在这个队列中诞生。每一次入队出队这个条件都不会变，搜索到一定程度其实可以停止了，那就是k自减为0

### 08号题目
* leetcode.67.二进制求和
* 思路：首先把短的字符串前面补上'0'，然后和长整数运算差不多

### 09号题目
* leetcode.190.颠倒二进制
* 思路：用res保存答案，每次res左移一位然后加上取出n的最后一位，然后n右移一位。总共循环32次

### 10号题目
* leetcode.191.位1的个数
* 思路：计数器cnt，每次检查一下n&1，如果是1，cnt++。然后n向右移位一位

### 11号题目
* leetcode.136.只出现过一次的数字
* 思路：异或的重要性质 a^a=0。所以一遍扫描全部异或，答案就是剩下的东西。0异或任何值a都=a

### 12号题目
* leetcode.137.只出现过一次的数字二
* 思路：如果一个数字出现三次，那么它各个二进制位也必定出现了三次，那么也就是说%3等于0。所以我们可以创建这样一个数组，来存储每个二进制位出现的总次数。最后模三，剩下的就是那个只出现一次的数的各个位
* 其实不管出现多少次，只要次数不同都可以考虑这种做法。只不过模的数字不同罢了
* 重复出现往往确实可以考虑模运算

### 13号题目
* leetcode.201.范围内数字与
* 思路：从高位往低位看，当前缀一致的时候那么高位就能保留。left和right分别是区间里的最小值和最大值，如果它们二者的某一高位可以相同，那么中间的也是相同的，因为递增是从地位开始的
* 这题目就转化为了求最长的高位序列
* ai给了一种优美的写法，可以学习一下。

### 14号题目
* leetcode.139.单词拆分
* 思路1：动态规划dp[i]表示前i个字符是可以构造出来的。进入循环，如果dp[i]是false，那么也没必要往下算了，前面都构造不出来也没有意义往后拼接。如果dp[i]为true。那么列举j从i+1到n,如果s[i]到s[j]这一段可以在字典里找到，那么就把s[j]变为true。值得注意的是，j是从i+1开始的，表示前i+1个字符是否能被构建出来，这是合理的，因为dp多一个dp[0]，而且dp[i]并非本轮循环构建的。最后返回dp[n]即可。
* 总结1：动态规划是一个从前往后推导答案的过程，所以我们一定要思考这些问题的子问题是什么，拆分的切入点在哪里。这里的逻辑就在于从前往后逐步构造，从小往大构造
* 思路2：dfs+记忆化数组。递归是一个大问题不断向小问题发问，直到小问题很容易解出来把结果逐层返回给大问题的过程。如果单纯的dfs这个题会超时，所以要用一个记忆化bool数组，对已经处理过的string标记为true或者false。如果起始点已经等于n，那么直接返回即可。如果搜索的string已经被标记，返回标记结果即可。否则就在原来的字典中找一个字符串，恰好可以在start为起点匹配一段字符串的字符串，找到之后，减去这段字符串，然后进入下一层问题。如果递归返回值是true，说明原串可以匹配到，记忆数组对它进行标记。如果都匹配失败，只能返回false，同样进行标记
* 通过字典中字符串的长度和当前的位置，以及问题原串的长度是个小的剪枝

### 15号题目
* leetcode.322.零钱兑换
* 思路：动态规划。首先分配一个ans(amount+1,-1)的数组，ans[0]初始化为0，ans[coins[i]]初始化为1。然后对于ans每一个元素，想到达这个元素，只有上一个值只有coins.size()种情况，而且这些情况本身的值不能小于0，必须也得达到。然后每次保存最小的方案数，用不同的coins进行比较和更新ans[j] = min(ans[j],ans[j-coins[i]]+1); （要考虑第一次）
* 另一种写法：coins是外循环，会更加简洁

### 16号题目
* leetcode.300.最长递增子序列
* 思路：分配一个ans(n,1)数组，因为最小就是本身。然后从i=1开始遍历数组，然后让j=0，j < i如果nums[i]>nums[j]   ans[i] = max(ans[i],ans[j]+1);最后找出ans中的最大值
* 错误原因：nums[i]>nums[j]写成了ans[i]>ans[j]。一个是条件数组，一个是结果数组

### 17号题目
* leetcode.120.三角形最小路径和
* 思路：动态规划.设置一个dp数组，结构和triangle相同，但是初值为MAX_INT/2。dp[i][j]表示路径结尾为triangle[i][j]路径的最小值，那么最终答案就是最后一行的最小值。初始化dp[0][0] = triangle[0][0]。然后从上往下递推，每个(i,j)可以影响(i+1,j)以及(i+1,j+1)。状态转移方程为dp[i+1][j] = min(dp[i+1][j],dp[i][j]+triangle[i+1][j]);和dp[i+1][j+1] = min(dp[i+1][j+1],dp[i][j]+triangle[i+1][j+1]);
* 别人的做法：从下往上推，而且空间用的是一维（因为每一行只依赖相邻的一行）。自底向上还有个好处就是我最后不用查找最小值在哪，肯定是f[0]。

### 18号题目
* leetcode.64.最小路径和
* 思路：动态规划，但是从右下角往左上角推。合法的路径是向上或者向左。而且每一行的结果只和下一行有关系，所以f数组只需设置为分f[n]。对最后一行初始化，将f[n-1] 初始化为右下角的元素，然后f[i]=f[i+1]+value,value为当前元素的值。f表示的是每一行从右下角到这个元素最小路径，只会记录一行，其余元素抛弃。然后从n-2行开始循环，最右的元素只能从往下一个元素来，所以单独运算，其它位置的元素利用状态转移方程f[j]=min(f[j+1],f[j])+grid[i][j];就可以了
* 别人的做法：有原地修改，但是实话实说我不太喜欢这样

### 19号题目
* leetcode.63.不同路径
* 思路：从左上角往右上角搜索，初始化一个二维dp[m][n]表示到每一个格子的路径数，dp[0][0]=1，其余初始化为0。每一个格子的前驱只有两个格子，如果这两个格子上没有障碍，那么就把方法数加入当前格子中。dp[i][j]+=dp[i][j-1];dp[i][j]+=dp[i-1][j];当然要注意边界条件
* 错误的原因：这个算法的缺陷是我没法判定头和尾是否有障碍物品，所以要额外进行判断
* 另一种写法：dp变成一维数组，会更加巧妙

### 20号题目
* leetcode.5.最大回文子串
* 思路1：中心扩散算法。首先我们得理解中心这个概念，回文串的中心要么是一个字符，要么就是连续的几个相同的字符。我们先扩展中心，分别向右和向左直到无法扩展为止。然后两端同时扩展，如果字符相同。每次扩展完之后和当前的maxlen进行比较，如果len比maxlen大，更新maxlen和maxstart
* 思路2：动态规划，动态规划的切入点在于每个回文串的内部必定是一个回文串。当串的左右两端s[l]=s[r]相等的时候，如果r-l<2(这样一定是一个回文串)或者子串dp[l+1][r-1]为回文串的时候，它也是一个回文串。这个题目动态规划的思路和我们前面的递推式的动态规划不太一样。
* 动态规划的启示：我开始质疑母问题会不会在子问题前计算，但是由于循环的限制，其实是不存在的。动态规划确实也要求子问题在母问题计算之前计算


## 007号文件
### 01号题目
* leetcode.97.交错字符串
* 思路：首先我们得找到动态规划的切入点，那就是找到它的子问题。那就是s1的前i的字符和s2的前j个字符是否可以构成s3的前i+j个字符。设置dp数组dp[i][j]表示前面说的条件。dp[0][0]=0;所以我们的i和j都可以取到lens1和lens2。但是实际探索s3的pos是i+j-1。因为这个才是i+j个字符的下标。dp[i][j]有两个前驱dp[i-1][j]和dp[i][j-1]。分别表示第i+j个字符用的是s1还是s2的字符。这里其实我有一点疑问，这里用true其实掩盖了路径，但是没有关系，如果路径不对的话那么必然会导致最后dp[m][n]也就是答案无法拼凑出来，放心好了。
* 有点晕了今天

### 02号题目
* leetcode.72.编辑距离
* 思路：主要是找到状态转移方程：如果word[i]==word[j]。那就不需要继续了，直接dp[i][j]=dp[i-1][j-1]。如果不等的话，那么就要进行一次操作，如果是插入那么对应dp[i][j-1]。因为i串多了一个字符，这个多的字符肯定是和j串匹配的，然后删掉i串长度不变j串减一。删除：dp[i-1][j]，那就是i串删去这个字符。替换：dp[i-1][j-1]替换之后强行匹配，双串减一。最后 dp[i][j] = min({dp[i][j-1],dp[i-1][j],dp[i-1][j-1]})+1;或者s[i]==s[j]的时候 dp[i][j] = dp[i-1][j-1]

### 03号题目
* leetcode.221.最大正方形
* 思路：这个题让我学到了一种新的正方形表示方式，(i,j)表示正方形右下角，dp[i][j]表示正方形的长度，这样就可以很好表示了。那么就是一个二维遍历，如果i或者j=0，那么它们处于矩形边界，就开matrix对应的值了，如果是'1'就是1，否则是0.其它的就有状态转移方程dp[i][j] = min({dp[i-1][j-1],dp[i][j-1],dp[i-1][j]})+1;其实很好理解。向左，向上，对角线三个方向搜索，只有三个方向都是1矩阵才能让ij变成1矩阵，至于它们是不是1矩阵，那就是子问题的子问题了


